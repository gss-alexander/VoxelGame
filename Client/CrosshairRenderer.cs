using System.Numerics;
using Silk.NET.OpenGL;

namespace Client;

// generated by AI for quick and dirty crosshair implementation

public class CrosshairRenderer
{
    private GL _gl;
    private uint _vao, _vbo;
    private uint _shaderProgram;
    private int _windowWidth, _windowHeight;

    private readonly string _vertexShaderSource = @"
        #version 330 core
        layout (location = 0) in vec2 aPosition;
        
        uniform mat4 uProjection;
        
        void main()
        {
            gl_Position = uProjection * vec4(aPosition, 0.0, 1.0);
        }";

    private readonly string _fragmentShaderSource = @"
        #version 330 core
        out vec4 FragColor;
        
        uniform vec3 uColor;
        
        void main()
        {
            FragColor = vec4(uColor, 1.0);
        }";

    public void Initialize(GL gl, int windowWidth, int windowHeight)
    {
        _gl = gl;
        _windowWidth = windowWidth;
        _windowHeight = windowHeight;

        CreateShaders();
        CreateCrosshairGeometry();
    }

    private void CreateShaders()
    {
        uint vertexShader = CompileShader(ShaderType.VertexShader, _vertexShaderSource);
        uint fragmentShader = CompileShader(ShaderType.FragmentShader, _fragmentShaderSource);

        _shaderProgram = _gl.CreateProgram();
        _gl.AttachShader(_shaderProgram, vertexShader);
        _gl.AttachShader(_shaderProgram, fragmentShader);
        _gl.LinkProgram(_shaderProgram);

        _gl.DetachShader(_shaderProgram, vertexShader);
        _gl.DetachShader(_shaderProgram, fragmentShader);
        _gl.DeleteShader(vertexShader);
        _gl.DeleteShader(fragmentShader);
    }

    private uint CompileShader(ShaderType type, string source)
    {
        uint shader = _gl.CreateShader(type);
        _gl.ShaderSource(shader, source);
        _gl.CompileShader(shader);

        _gl.GetShader(shader, ShaderParameterName.CompileStatus, out int success);
        if (success == 0)
        {
            string infoLog = _gl.GetShaderInfoLog(shader);
            throw new Exception($"Shader compilation failed: {infoLog}");
        }

        return shader;
    }

    private void CreateCrosshairGeometry()
    {
        float[] vertices = new float[]
        {
            // Horizontal line
            -10.0f,  0.0f,
             10.0f,  0.0f,
            
            // Vertical line
             0.0f, -10.0f,
             0.0f,  10.0f
        };

        _vao = _gl.GenVertexArray();
        _gl.BindVertexArray(_vao);

        _vbo = _gl.GenBuffer();
        _gl.BindBuffer(BufferTargetARB.ArrayBuffer, _vbo);
        
        unsafe
        {
            fixed (float* v = vertices)
            {
                _gl.BufferData(BufferTargetARB.ArrayBuffer, (nuint)(vertices.Length * sizeof(float)), v, BufferUsageARB.StaticDraw);
            }
        }

        _gl.VertexAttribPointer(0, 2, VertexAttribPointerType.Float, false, 2 * sizeof(float), 0);
        _gl.EnableVertexAttribArray(0);

        _gl.BindVertexArray(0);
    }

    public void Render()
    {
        // Create orthographic projection matrix
        Matrix4x4 projection = Matrix4x4.CreateOrthographic(_windowWidth, _windowHeight, -1.0f, 1.0f);

        _gl.UseProgram(_shaderProgram);

        // Set uniforms
        int projectionLocation = _gl.GetUniformLocation(_shaderProgram, "uProjection");
        int colorLocation = _gl.GetUniformLocation(_shaderProgram, "uColor");

        unsafe
        {
            _gl.UniformMatrix4(projectionLocation, 1, false, (float*)&projection);
        }

        // Set crosshair color (white)
        _gl.Uniform3(colorLocation, 1.0f, 1.0f, 1.0f);

        // Disable depth testing for UI
        _gl.Disable(EnableCap.DepthTest);
        
        // Enable line width (optional)
        _gl.LineWidth(2.0f);

        _gl.BindVertexArray(_vao);
        _gl.DrawArrays(PrimitiveType.Lines, 0, 4);
        _gl.BindVertexArray(0);

        // Re-enable depth testing
        _gl.Enable(EnableCap.DepthTest);
    }

    public void UpdateWindowSize(int width, int height)
    {
        _windowWidth = width;
        _windowHeight = height;
    }

    public void Cleanup()
    {
        _gl.DeleteVertexArray(_vao);
        _gl.DeleteBuffer(_vbo);
        _gl.DeleteProgram(_shaderProgram);
    }
}